{-
    BNF Converter: Scala Bison generator
    Copyright (C) 2004  Author:  Michael Pellauer
    Copyright (C) 2016  Author:  Eric Finster

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-}

{-
   **************************************************************
    BNF Converter Module

    Description   : This module generates the Bison input file.
                    Note that because of the way bison stores results
                    the programmer can increase performance by limiting
                    the number of entry points in their grammar.

    Author        : Michael Pellauer (pellauer@cs.chalmers.se)
                    Eric Finster (ericfinster@gmail.com)

    License       : GPL (GNU General Public License)

    Created       : 6 August, 2003

    Modified      : 6 August, 2003
                    6 September, 2016

   **************************************************************
-}


module BNFC.Backend.Scala.CFtoBisonScala (cf2Bison, startSymbol) where

import BNFC.CF
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import BNFC.Backend.Common.NamedVariables hiding (varName)
import BNFC.Utils ((+++))

--import Debug.Trace(trace)

--This follows the basic structure of CFtoHappy.

-- Type declarations
type Rules       = [(NonTerminal,[(Pattern,Action)])]
type Pattern     = String
type Action      = String
type MetaVar     = String

--The environment comes from the CFtoFlex
cf2Bison :: String -> String -> CF -> SymEnv -> String
cf2Bison pkgName lname cf env = unlines $
  [ header pkgName cf
  , "%token ERROR"
  , "%token NOP"
  , tokens user env
  , declarations cf
  , specialToks cf
  , startSymbol cf
  , "%%"
  , prRules (rulesForBison cf env)
  , "%%"
  , "  def yyerror(s:String): Unit = { println(s) }"
  , "  private var theLexer: MinittLexer = null"
  , "  def lexer: MinittLexer = theLexer"
  , "  def lexer_=(l: MinittLexer): Unit = { yyreset(l.iterator) }"
  , "  def parseAll: Option[" ++ sc ++ "] ="
  , "    try {"
  , "      val res = parse_" ++ ss ++ "()"
  , "      parse_YYEOF()"
  , "      Some(res)"
  , "    } catch {"
  , "      case YYError(_) => None"
  , "    }"
  ] ++ definedRules cf
  where
   user = fst (unzip (tokenPragmas cf))
   ss = identCat (firstEntry cf)
   sc = varName (firstCat cf)

header :: String -> CF -> String
header pkgName cf = unlines
         ["/* This Bison file was machine-generated by BNFC */",
          "%{",
          "package " ++ pkgName ,
          "%}"
          ]

--declares non-terminal types.
declarations :: CF -> String
declarations cf = concatMap (typeNT cf) (allCats cf)
 where --don't define internal rules
   typeNT cf nt | rulesForCat cf nt /= [] = "%type <" ++ varName nt ++ "> " ++ identCat nt ++ "\n"
   typeNT _ _ = ""

--declares terminal types.
tokens :: [UserDef] -> SymEnv -> String
-- tokens user env | trace ("user tokens: " ++ concat (map show user)) False = undefined
-- tokens user env | trace ("symbols: " ++ concat (map (show . fst) env)) False = undefined
tokens user env = concatMap (declTok user) env
 where
  declTok u (s,r) = if s `elem` map show u
    then "%token<String> " ++ r ++ "    /*   " ++ s ++ "   */\n"
    else "%token " ++ r  ++ "    /*   " ++ s ++ "   */\n"


specialToks :: CF -> String
specialToks cf = concat [
  ifC catString "%token<String> SYMB_STRING\n",
  ifC catChar "%token<Char> SYMB_CHAR\n",
  ifC catInteger "%token<Int> SYMB_INTEGER\n",
  ifC catDouble "%token<Double> SYMB_DOUBLE\n",
  ifC catIdent "%token<String> SYMB_IDENT\n"
  ]
   where
    ifC cat s = if isUsedCat cf cat then s else ""

startSymbol :: CF -> String
startSymbol cf = "%start" +++ identCat (firstEntry cf)

--The following functions are a (relatively) straightforward translation
--of the ones in CFtoHappy.hs
rulesForBison :: CF -> SymEnv -> Rules
rulesForBison cf env = map mkOne $ ruleGroups cf where
  mkOne (cat,rules) = constructRule cf env rules cat

-- For every non-terminal, we construct a set of rules.
constructRule :: CF -> SymEnv -> [Rule] -> NonTerminal -> (NonTerminal,[(Pattern,Action)])
constructRule cf env rules nt = (nt,[(p, generateAction (identCat (normCat nt)) (funRule r) b m) |
     r0 <- rules,
     let (b,r) = if isConsFun (funRule r0) && elem (valCat r0) revs
                   then (True,revSepListRule r0)
                 else (False,r0),
     let (p,m) = generatePatterns cf env r])
 where
   revs = cfgReversibleCats cf
   -- eps = allEntryPoints cf
   -- isEntry nt = nt `elem` eps
   -- result = if isEntry nt then resultName (identCat (normCat nt)) ++ "= $$;" else ""

--
--  NOTE: I have not yet worked out the list reversal requirements
--  so that these rules may generate errors in the case of left-recursive
--  list optimizations.
--

-- | Generates a string containing the semantic action.
-- >>> generateAction "Foo" "Bar" False ["$1"]
-- "make_Bar($1);"
-- >>> generateAction "Foo" "_" False ["$1"]
-- "$1;"
-- >>> generateAction "ListFoo" "[]" False []
-- "0;"
-- >>> generateAction "ListFoo" "(:[])" False ["$1"]
-- "make_ListFoo($1, 0);"
-- >>> generateAction "ListFoo" "(:)" False ["$1","$2"]
-- "make_ListFoo($1, $2);"
-- >>> generateAction "ListFoo" "(:)" True ["$1","$2"]
-- "make_ListFoo($2, $1);"
generateAction :: String -> Fun -> Bool -> [MetaVar] -> Action
generateAction nt f b ms 
  | isCoercion f = unwords ms ++ ";"
  | isNilFun f   = "Nil;"
  | isOneFun f   = concat ["List(", intercalate ", " ms', ");"] 
  | isConsFun f  = concat [intercalate " :: " ms', ";"]
  | otherwise    = concat [f, "(", intercalate ", " ms', ");"]
 where
  ms' = if b then reverse ms else ms

-- Generate patterns and a set of metavariables indicating
-- where in the pattern the non-terminal
generatePatterns :: CF -> SymEnv -> Rule -> (Pattern,[MetaVar])
generatePatterns cf env r = case rhsRule r of
  []  -> ("/* empty */",[])
  its -> (unwords (map mkIt its), metas its)
 where
   mkIt i = case i of
     Left c -> fromMaybe (typeName (identCat c)) (lookup (show c) env)
     Right s -> fromMaybe s (lookup s env)
   metas its = [revIf c ('$': show i) | (i,Left c) <- zip [1 :: Int ..] its]
   revIf c m = if not (isConsFun (funRule r)) && elem c revs
                 then "reverse" ++ identCat (normCat c) ++ "(" ++ m ++ ")"
               else m  -- no reversal in the left-recursive Cons rule itself
   revs = cfgReversibleCats cf

-- We have now constructed the patterns and actions,
-- so the only thing left is to merge them into one string.

prRules :: Rules -> String
prRules [] = []
prRules ((_, []):rs) = prRules rs --internal rule
prRules ((nt, (p,a) : ls):rs) =
  unwords [nt', ":" , p, "{ $$ =", a, "}", '\n' : pr ls] ++ ";\n" ++ prRules rs
 where
  nt' = identCat nt
  pr []           = []
  pr ((p,a):ls)   = unlines [unwords ["  |", p, "{ $$ =", a , "}"]] ++ pr ls

-- | slightly stronger than the NamedVariable version.
-- >>> varName (Cat "Abc")
-- "abc_"
varName :: Cat -> String
varName c = idCat (normCat c)
  where idCat (ListCat c) = "List[" ++ idCat c ++ "]"
        idCat c           = show c ++ "T"

typeName :: String -> String
typeName "Ident" = "SYMB_IDENT"
typeName "String" = "SYMB_STRING"
typeName "Char" = "SYMB_CHAR"
typeName "Integer" = "SYMB_INTEGER"
typeName "Double" = "SYMB_DOUBLE"
typeName x = x

-- The following is a very crude type extraction mechanism
-- so that we can synthesize the defined rules, which, in Scala,
-- must have their parameters type-annotated.

allRules :: CF -> [(Fun,[Cat])]
allRules cf = concat $ map snd (getAbstractSyntax cf)

argCats :: CF -> Fun -> Maybe [Cat]
argCats cf f = lookup f (allRules cf) 

definedRules :: CF -> [String]
definedRules cf = [ mkDef f xs e | FunDef f xs e <- cfgPragmas cf ]
  where

    doTyping f xs e = do
      typing <- checkArg cf xs e InternalCat
      sequence (map (\x -> lookup x typing >>= \c -> return $ varName c) xs)

    mkDef f xs e = case doTyping f xs e of
      Nothing -> ""
      Just typing -> concat ["  def ", f, "(", params, ") = ", printExpr e, ";"]
                       where params = intercalate ", " (map (\(x,t) -> x ++ " : " ++ t) (zip xs typing))

                             printExpr (LitInt i) = show i
                             printExpr (LitDouble d) = show d
                             printExpr (LitChar c) = show c
                             printExpr (LitString s) = s 
                             printExpr (App f []) = if (f `elem` xs) then f else f ++ "()"
                             printExpr (App f xs) = f ++ "(" ++ intercalate ", " (map printExpr xs) ++ ")"

checkArg :: CF -> [String] -> Exp -> Cat -> Maybe [(String, Cat)]
checkArg cf vars (LitInt _) (TokenCat "Integer") = Just []
checkArg cf vars (LitDouble _) (TokenCat "Double") = Just []
checkArg cf vars (LitChar _) (TokenCat "Char") = Just []
checkArg cf vars (LitString _) (TokenCat "String") = Just []
checkArg cf vars (App f []) cat =
  if f `elem` vars then Just [(f, cat)] else Just [] -- Actually perform a check here?
checkArg cf vars (App f args) cat = do
  acs <- argCats cf f
  argConstraints <- sequence $ map (\(a, ac) -> checkArg cf vars a ac) (zip args acs)
  return $ concat argConstraints
